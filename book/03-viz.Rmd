# Basic Data Visualisation {#viz}

## Intended Learning Outcomes {#ilo-viz}

* Understand the difference between categorical and continuous data
* Create plots in layers using ggplot
* Be able to choose appropriate plots for data

```{r, message=FALSE}
library(ggplot2)
library(patchwork)
library(ggthemes)
library(lubridate)
```


## Variable Types

If a spreadsheet is in a ` r glossary("tidy data")` format, each row is an `r glossary("observation")`, each column is a `r glossary("variable")`, and the information in each cell is a `r glossary("value")`. We'll learn more about how to get our data into this format in Chapter\ \@ref(tidy), but to get started we'll use built-in datasets with the right format.

For example, the table below lists pets owned by members of the psyTeachR team. Each row is an observation of one pet. There are 5 variables for each pet, their `name`, `owner`, `species`, `weight`, and `rating`.

```{r, echo = FALSE}
tribble(
  ~name,      ~owner, ~species, ~weight, ~rating,
  "Darwin",   "Lisa", "ferret",  1.2,    "a little evil",
  "Oy",       "Lisa", "ferret",  2.9,    "very good",
  "Khaleesi", "Emily", "cat",    4.5,    "very good",
  "Bernie",   "Phil",  "dog",   32.0,    "very good"
)
```

When you're plotting data, it's important to know what type of variables you have.

### Continuous

`r glossary("Continuous")` variables are properties you can measure, like weight. Continuous variables are always numbers. They may be rounded to the nearest whole number, but it should make sense to have a measurement halfway between.

### Categorical

`r glossary("Categorical")` variables are properties you can count, like the number of pets of each species. Categorical variables can be `r glossary("nominal")`, where the categories don't really have an order, like cats, dogs and ferrets (even though ferrets are obviously best). Sometimes people represent categorical variables with numbers that correspond to names, like 0 = "no" and 1 = "yes", but values in between don't have a clear interpretation. If you have control over how the data are recorded, it's better to use the text names for clarity, but you'll learn how to recode columns in Chapter\ \@ref(wrangle).

### Ordinal

`r glossary("Ordinal")` variables are a type of categorical variable with a clear order, but the distance between the categories isn't something you could exactly equate, like points on a `r glossary("Likert")` rating scale. Even if a data table uses numbers like 1-7 to represent ordinal variables, you shouldn't treat them like continuous variables.

### Dates and Times

Dates and times are a special case of variable. They can act like categorical or continuous variables, and there are special ways to plot them.


## Building Plots

```{r sim-survey, include = FALSE}
library(faux)
set.seed(8765309)

issues <- c(
  tech = 0, 
  sales = 2, 
  returns = 1,
  other = 1
)

survey_data <- add_random(employee_id = 10) %>%
  add_random(caller_id = sample(50:100, 10), 
             .nested_in = "employee_id") %>%
  mutate(call_start = runif(nrow(.), 2020, 2021) %>% date_decimal()) %>%
  add_ranef("caller_id", wait_time = 1, call_time = 1, .cors = 0.5) %>%
  mutate(wait_time = norm2beta(wait_time, 2, 4, ncp=10) * 5,
         call_time = norm2beta(call_time, 2, 4, ncp=0) * 2 + 0.5,
         # round and add outliers
         wait_time = round(wait_time * 60) + 
           sample(c(0, 100), nrow(.), T, c(99, 1)),
         call_time = round(call_time * 60) + 
           sample(c(0, 100), nrow(.), T, c(99, 1))
  ) %>%
  add_between("caller_id", issue_category = names(issues), 
              .prob = c(.4, .1, .3, .1)) %>%
  add_ranef("employee_id", employee_quality = 1) %>%
  add_ranef(error = 1) %>%
  mutate(satisfaction = (employee_quality + 
           recode(issue_category, !!!issues) -
           (wait_time * .1) + 
           error) %>% norm2likert(c(1,2,3,2,1))) %>%
  select(caller_id, employee_id, call_start, wait_time, call_time,
         issue_category, satisfaction)

write_csv(survey_data, "data/survey_data.csv")
```


### Layered Plots

Figure\ \@ref(fig:layers) displays the evolution of a simple scatterplot using this layered approach. First, the plot space is built (layer 1); the variables are specified (layer 2); the type of visualisation (known as a `geom`) that is desired for these variables is specified (layer 3) - in this case `geom_point()` is called to visualise individual data points; a second geom is added to include a line of best fit (layer 4), the axis labels are edited for readability (layer 5), and finally, a theme is applied to change the overall appearance of the plot (layer 6).

```{r layers, fig.cap="Evolution of a layered plot", echo = FALSE, message=FALSE}
survey_data <- read_csv(file = "data/survey_data.csv")

x_breaks <- seq(from = 0, to = 600, by = 60)
y_breaks <- seq(from = 0, to = 600, by = 30)
xlim <- c(0, max(survey_data$wait_time) + 10)
ylim <- c(0, max(survey_data$call_time) + 10)

a <- ggplot() + labs(subtitle = "Layer 1")
b <- ggplot(survey_data, aes(x = wait_time, y = call_time)) + 
  labs(subtitle = "Layer 2")
c <- b + geom_point(alpha = 0.2, color = "dodgerblue") + 
  labs(subtitle = "Layer 3")
d <- c + geom_smooth(method = "lm", color = rgb(0, .5, .8)) + 
  labs(subtitle = "Layer 4")
e <- d + scale_x_continuous(name = "Wait Time (min)", 
                            breaks = x_breaks,
                            labels = x_breaks/60,
                            limits = xlim) +
  scale_y_continuous(name = "Call time (min)",
                     breaks = y_breaks,
                     labels = format(y_breaks/60, digits = 1),
                     limits = ylim) + 
  labs(subtitle = "Layer 5")
f <- e + ggthemes::theme_gdocs(base_size = 11, base_family = "Times") + 
  theme(axis.line.x = element_blank(),
        plot.background = element_blank()) +
  labs(subtitle = "Layer 6") +
  theme(plot.subtitle =  element_text(family = "Arial", color = "black"))

a + b + c + d + e + f + plot_layout(nrow = 2)
```

Importantly, each layer is independent and independently customisable. For example, the size, colour and position of each component can be adjusted, or one could, for example, remove the first geom (the data points) to only visualise the line of best fit, simply by removing the layer that draws the data points (Figure\ \@ref(fig:remove-layer)). The use of layers makes it easy to build up complex plots step-by-step, and to adapt or extend plots from existing code.

```{r remove-layer, fig.cap="Plot with scatterplot layer removed.", echo = FALSE}
ggplot(survey_data, aes(x = wait_time, y = call_time)) + 
  #geom_point(alpha = 0.15, color = "dodgerblue") +
  geom_smooth(method = "lm", formula = y~x, color = rgb(0, .5, .8)) +
  scale_x_continuous(name = "Wait Time (min)", 
                            breaks = seq(0, 600, 60),
                            labels = 0:10,
                            limits = xlim) +
  scale_y_continuous(name = "Call time (min)",
                     breaks = seq(0, 600, 30),
                     labels = seq(0, 10, .5) %>% format(digits = 1),
                     limits = ylim) + 
  theme_minimal(base_family = "Times") + 
  theme(panel.grid.minor = element_blank())
```

### Loading Data

Let's build up a simple version of the plot above, layer by layer. First we need to get the data. We'll learn how to load data in Chapter\ \@ref(data), but you can copy the code below to create a data table object. The "column specification" tells you what each column is named and what type of data it is. A `r glossary("double")` is a kind of `r glossary("numeric")` value that can have decimal places.

```{r}
survey_data <- read_csv(file = "data/survey_data.csv")
```

This data is simulated data for a call centre customer satisfaction survey. The first thing you should do when you need to plot data is to get familiar with what all of the rows (observations) and columns (variables) mean. Sometimes this is obvious, and sometimes it requires help from the data provider. Here, each row represents one call to the centre.

* `caller_id` is a unique ID for each caller
* `employee_id` is a unique ID for each employee taking calls
* `call_start` is the date and time that the call arrived
* `wait_time` is the number of seconds the caller had to wait
* `call_time` is the number of seconds the call lasted after the employee picked up
* `issue_category` is whether the issue was `r paste(names(issues), collapse = ", ")`
* `satisfaction` is the customer satisfaction rating on a scale from 1 (very unsatisfied) to 5 (very satisfied)

### Plot setup

Every plot starts with the `ggplot()` function and a data table. If your data are not loaded or you have a typo in your code, this will give you an error message. It's best to check your plot after each step so you can figure out where errors are more easily.

```{r}
ggplot(data = survey_data)
```

### Mapping

The next `r glossary("argument")` to `ggplot()` is the `mapping`. This tells the plot which columns in the data should be represented by different "aesthetics" of the plot, such as the x-axis, y-axis, line colour, object fill, or line style.

The `mapping` argument requires an `aes()` function that can take the arguments `x` and `y`. Set those to the names of the columns you want to be plotted on those axes. Here, we want to plot the wait time on the x-axis and the call time on the y-axis.

```{r}
# set up the mapping
wait_vs_call <- aes(x = wait_time, 
                    y = call_time)

# set up the plot
ggplot(data = survey_data, mapping = wait_vs_call)
```


::: {.info data-latex=""}
You will often see the two steps above (setting up the mapping and setting up the plot) combined like below. If you put arguments in the right order, you don't need to use their names, and you can put the `aes()` function directly in the second argument. Once you're very familiar with plotting, this shortcut will make sense, but we'll use the longer, clearer version to start.

```{r, eval = FALSE}
ggplot(survey_data, aes(x = wait_time, y = call_time))
```

:::

### Geoms

Now we can add our plot elements in layers. These are referred to as `r glossary("geom", "geoms")` and their functions start with `geom_`. You **add** layers onto the base plot created by `ggplot()` with a plus (`+`). 

```{r}
ggplot(data = survey_data, mapping = wait_vs_call) +
  geom_point() # scatterplot
```

::: {.warning data-latex=""}
Somewhat annoyingly, the plus has to be on the end of the previous line, not at the start of the next line. If you do make this mistake, you will get the following error message.

```{r, error = TRUE}
g <- ggplot(data = survey_data, mapping = wait_vs_call)
  + geom_point() # scatterplot
```
:::

### Multiple Geoms

You can add more than one geom. They display in the order you set them up. In the code below, we make two different plots and assign them to `r glossary("object", "objects")` that we can add together using the `plot_layout()` function from the `r pkg("patchwork")` package.

```{r}
point_first <- 
  ggplot(data = survey_data, mapping = wait_vs_call) +
  geom_point() + # scatterplot
  geom_smooth(method = lm) # line of best fit
  
line_first <-
  ggplot(data = survey_data, mapping = wait_vs_call) +
  geom_smooth(method = lm) + # line of best fit
  geom_point() # scatterplot

# add plots together in 1 row
point_first + line_first + plot_layout(nrow = 1)
```


### Styling Geoms

We should definitely put the line in front of the points, but the points are still a bit dark. If you want to change the overall style of a geom (not use it to represent different levels of a variable), you can set arguments inside the geom function. See Appendix\ \@ref(plotstyle) for more information about the ways to style plot aesthetics.


```{r}
ggplot(data = survey_data, mapping = wait_vs_call) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2,
             shape = 18,
             size = 2) + 
  geom_smooth(method = lm, 
              formula = y~x, # default value; avoids annoying message
              colour = rgb(0, .5, .8),
              linetype = 3) 
```


::: {.try data-latex=""}
Play around with different values for the aesthetics above. Figure out what the default values are for `shape` and `size`.
:::

### Format Axes

Now we need to make the axes look neater. There are several functions you can use to change the axis labels, but the most powerful ones are the `scale_` functions. You need to use a scale function that matches the data you're plotting on that axis. Both of the axes here are `r glossary("continuous")`, so we'll use `scale_x_continuous()` and `scale_y_continuous()`.

The `name` argument changes the axis label. The `breaks` argument sets the major units and needs a `r glossary("vector")` of possible values, which can extend beyond the range of the data (e.g., `wait time` only goes up to 350, but we can specify breaks up to 600). The `seq()` function creates a sequence of numbers `from` one `to` another `by` specified steps.

```{r}
# set the breaks
x_breaks <- seq(from = 0, to = 600, by = 60)
y_breaks <- seq(from = 0, to = 600, by = 30)

ggplot(data = survey_data, mapping = wait_vs_call) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2) + 
  geom_smooth(method = lm, 
              formula = y~x, 
              colour = rgb(0, .5, .8)) +
  scale_x_continuous(name = "Wait Time (seconds)", 
                     breaks = x_breaks) +
  scale_y_continuous(name = "Call time (seconds)",
                     breaks = y_breaks)
```

::: {.try data-latex=""}
Check the help for `?scale_x_continuous` to see how you would set the minor units or specify how many breaks you want instead.
:::

We can change how the axis text displays by setting the `labels` argument. Let's change this to minutes instead of seconds by dividing the labels by 60. 

```{r}
ggplot(data = survey_data, mapping = wait_vs_call) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2) + 
  geom_smooth(method = lm, 
              formula = y~x, 
              colour = rgb(0, .5, .8)) +
  scale_x_continuous(name = "Wait Time (minutes)", 
                     breaks = x_breaks,
                     labels = x_breaks/60) +
  scale_y_continuous(name = "Call time (minutes)",
                     breaks = y_breaks,
                     labels = y_breaks/60)
```

If you want to change the minimum and maximum values on an axis, use the `limits` argument. Many plots make more sense if the minimum and maximum values represent the range of possible values, even if those values aren't present in the data. Here, wait and call times can't be less than 0 seconds, so we'll set the minimum values to 0 and the maximum values to 10 seconds above the highest value in the data.


```{r}
# set the axis limits
xlim <- c(0, max(survey_data$wait_time) + 10)
ylim <- c(0, max(survey_data$call_time) + 10)

ggplot(data = survey_data, mapping = wait_vs_call) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2) + 
  geom_smooth(method = lm, 
              formula = y~x, 
              colour = rgb(0, .5, .8)) +
  scale_x_continuous(name = "Wait Time (minutes)", 
                     breaks = x_breaks,
                     labels = x_breaks/60,
                     limits = xlim) +
  scale_y_continuous(name = "Call time (minutes)",
                     breaks = y_breaks,
                     labels = format(y_breaks/60, digits = 1),
                     limits = ylim)
```

::: {.info data-latex=""}
The y-axis has increments of 30 seconds, so to make sure the whole numbers also have a decimal place (e.g., "1.0" instead of "1"), we used the `format()` function to set the number of decimal places to display.
:::

### Themes

`r pkg("ggplot2")` comes with several built-in themes, such as `theme_minimal()` and `theme_bw()`, but the `r pkg("ggthemes", "https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/")` package provides even more themes that match different software, such as GoogleDocs or Stata, or publications, such as the Economist or the Wall Street Journal. Let's add the GoogleDocs theme, but change the font size to 11 with the `base_size` argument and change the font to "Times" with the `base_family` argument.

```{r}
ggplot(data = survey_data, mapping = wait_vs_call) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2) + 
  geom_smooth(method = lm, 
              formula = y~x, 
              colour = rgb(0, .5, .8)) +
  scale_x_continuous(name = "Wait Time (minutes)", 
                     breaks = x_breaks,
                     labels = x_breaks/60,
                     limits = xlim) +
  scale_y_continuous(name = "Call time (minutes)",
                     breaks = y_breaks,
                     labels = format(y_breaks/60, digits = 1),
                     limits = ylim) +
  ggthemes::theme_gdocs(base_size = 11, base_family = "Times")
```

### Theme Tweaks

If you're still not quite happy with a theme, you can customise it even further with the `themes()` function. Check the help for this function to see all of the possible options. The most common thing you'll want to do is to remove an element entirely. You do this by setting the relevant argument to `element_blank()`. Below, we're getting rid of the x-axis line and the plot background, which removes the line around the plot.

```{r}
ggplot(data = survey_data, mapping = wait_vs_call) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2) + 
  geom_smooth(method = lm, 
              formula = y~x, 
              colour = rgb(0, .5, .8)) +
  scale_x_continuous(name = "Wait Time (minutes)", 
                     breaks = x_breaks,
                     labels = x_breaks/60,
                     limits = xlim) +
  scale_y_continuous(name = "Call time (minutes)",
                     breaks = y_breaks,
                     labels = format(y_breaks/60, digits = 1),
                     limits = ylim) +
  ggthemes::theme_gdocs(base_size = 11, base_family = "Times") +
  theme(axis.line.x = element_blank(),
        plot.background = element_blank())
```


## Appropriate Plots

The [ggplot2 cheat sheet](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf) is a great resource to help you find plots appropriate to your data. The examples below all use the same customer satisfaction data, but each plot communicates something different. 

We don't expect you to memorise all of the plot types or the methods for customising them, but it will be helpful to try out the code in the examples below for yourself, changing values to test your understanding.

### Counting Categories

If you want to count the number of things per category, you can use `geom_bar()`.

```{r}
count_issues <- aes(x = issue_category)

ggplot(data = survey_data, mapping = count_issues) +
  geom_bar()
```


We'll want to customise some things about this, like the colours, order of the columns, and their labels. Inspect the code below to figure out where these things change. The functions `scale_fill_manual()` and `scale_x_discrete()` are new, but work in the same way as the other `scale_` functions.

```{r}
# gives each issue a different colour
count_issues <- aes(x = issue_category,
                    fill = issue_category) 

# change the deafult order and colours
new_colors <- c(tech = "goldenrod", 
                returns = "darkgreen", 
                sales = "dodgerblue3", 
                other = "purple3")
new_order <- c("tech", "returns", "sales", "other")
new_labels <- c("Technical", "Returns", "Sales", "Other")

ggplot(data = survey_data, mapping = count_issues) +
  geom_bar() +
  scale_x_discrete(
    name = "Issue Category", # change axis title
    limits = new_order, # change order
    labels = new_labels # change labels
  ) +
  scale_fill_manual(
    values = new_colors, # change colours
    guide = "none" # remove the legend
  ) +
  scale_y_continuous(
    name = "", # remove axis title
    # remove the space above and below the y-axis
    expand = expansion(add = 0), 
    limits = c(0, 350) # minimum = 0, maximum = 350
  ) +
  ggtitle("Number of issues per category") # add a title
```

### Continuous Distribution

If you have a continuous variable, like the number of seconds callers have to wait, you can use `geom_histogram()` to show the distribution. 

```{r, fig.cap="Histogram of wait times."}
ggplot(data = survey_data, mapping = aes(x = wait_time)) +
  geom_histogram()
```

You should always set the `binwidth` or number of `bins` to something meaningful for your data (otherwise you get that annoying message). You might need to try a few options before you find something that looks good and conveys the meaning of your plot; `binwidth = 15` seems to work well here. 

By default, the bars start *centered* on 0, so the first bar would include -7.5 to 7.5 seconds, which doesn't make much sense. We can set `boundary = 0` so that each bar represents increments of 15 seconds *starting* from 0. 

The default style of grey bars is ugly, so you can change that by setting the `fill` and `colour`. 

We can also set up a custom the x-axis called `wait_x` so we can reuse it in other plots.

```{r, fig.cap="Histogram with custom styles."}
# set up x-axis 
wait_x <- scale_x_continuous(
  name = "Wait time (minutes)",
  breaks = seq(0, 600, 60),
  labels = seq(0, 600, 60)/60,
  limits = c(0, 360)
)

# style histogram
ggplot(data = survey_data, mapping = aes(x = wait_time)) +
  geom_histogram(boundary = 0, binwidth = 15, 
                 fill = "white", color = "black") +
  wait_x
```

### Grouped Continuous Distribution

You can set the `fill` aesthetic in the mapping to show what proportion of each bin comes from each category. By default, the categories are positioned stacked on top of each other. The function `geom_area()` gives a similar effect when `stat = "bin"`. 

```{r, fig.height = 3, fig.width = 8, fig.cap="Stacked histogram."}
# set fill by issue category
wait_by_issue <- aes(x = wait_time, fill = issue_category)

# stacked histogram
histogram_stack <- ggplot(data = survey_data, mapping = wait_by_issue) +
  geom_histogram(boundary = 0, 
                 binwidth = 15, 
                 color = "black") +
  wait_x + 
  ggtitle("Stacked Histogram")

# area plot
area_plot <- ggplot(data = survey_data, mapping = wait_by_issue) +
  geom_area(stat = "bin", 
            boundary = 0, 
            binwidth = 15, 
            color = "black",
            show.legend = FALSE) +
  wait_x +
  ggtitle("Area")

histogram_stack + area_plot + 
  plot_layout(nrow = 1, guides = "collect")
```

::: {.warning data-latex=""}
Make sure to remove the `fill` argument from `geom_histogram()`, or it will overwrite the colours set in the mapping.
:::

If you want to compare more than one distribution, you can set the `position` argument of `geom_histogram()` to "dodge", but this can look confusing with several categories. You can use`geom_freqpoly()` to plot a line connecting the top of each bin. Which you choose depends on what point you are trying to make with the plot.

```{r, fig.height = 3, fig.width = 8, fig.cap = "Different ways to plot the distribution of a continuous variable for multiple groups."}
# set both fill and colour to differ by issue category
wait_by_issue <- aes(x = wait_time, 
                     fill = issue_category, 
                     colour = issue_category)

# dodged histogram
histogram_dodge <- ggplot(data = survey_data, mapping = wait_by_issue) +
  geom_histogram(boundary = 0, 
                 binwidth = 15, 
                 position = "dodge") +
  wait_x + 
  ggtitle("Dodged Histogram")

# frequency plot
freqpoly_plot <- ggplot(data = survey_data, mapping = wait_by_issue) +
  geom_freqpoly(binwidth = 15, 
                boundary = 0,
                size = 1) +
  wait_x +
  ggtitle("Frequency")

# paste the three plots together
histogram_dodge + freqpoly_plot + 
  plot_layout(nrow = 1, guides = "collect")
```


### Two Continuous Distributions

When you want to see how two continuous variables are related, set one as the x-axis and the other as the y-axis. Usually, if one variable causes the other, you plot the cause on the x-axis and the effect on the y-axis. Here, we want to see if longer wait times cause the calls to be longer. 

```{r}
wait_by_call <- aes(x = wait_time,
                    y = call_time)

# assign the base plot to a variable to use later
g <- ggplot(data = survey_data, mapping = wait_by_call)

g + geom_point()
```


```{r, fig.cap="Different ways to show the relationship between two continuous variables."}

point_plot <- g +
  geom_point(alpha = 0.2) +
  ggtitle("Point Plot")

smooth_plot <- g +
  geom_smooth(method = "loess", formula = y~x) +
  ggtitle("Smooth")

lm_plot <- g +
  geom_smooth(method = lm, formula = y~x) +
  ggtitle("Linear")

combo_plot <- g +
  geom_point(alpha = 0.2) +
  geom_smooth(method = lm, formula = y~x) +
  ggtitle("Combo")

point_plot + smooth_plot + lm_plot + combo_plot
```

### Dates

The `call_start` column contains both a date and a time, so use the `date()` function from `r pkg("lubridate")` to convert it to just a date. We'll need this to be able to transform the x-axis below.

```{r}
satisfaction_by_date <- aes(x = lubridate::date(call_start),
                            y = satisfaction)

# assign the base plot to a variable to use later
g <- ggplot(data = survey_data, mapping = satisfaction_by_date)

g + geom_smooth(method = lm,  formula = y~x)
```

We can use `scale_x_date()` to set the `date_breaks` to be "1 month" apart. The `date_labels` use a code for different date formats, which you can see in the help for `?strptime`. For example, you can change the dates to a format like "2020/01/31" with the formatting string `"%Y/%m/%d"`.



```{r}
g + geom_smooth(method = lm,  formula = y~x) +
  scale_x_date(name = "",
               date_breaks = "1 month", 
               date_labels = "%b") +
  scale_y_continuous(name = "Caller Satisfaction") +
  ggtitle("2020 Caller Satisfaction")
```

::: {.try data-latex=""}
It looks like customer satisfaction declined a bit in the first half of the year, but is this change meaningful? See what the plot looks like when the y-axis spans the full range of possible satisfaction values from 1 to 5.

```{r, webex.hide}
g + geom_smooth(method = lm,  formula = y~x) +
  scale_x_date(name = "",
               date_breaks = "1 month", 
               date_labels = "%b") +
  scale_y_continuous(name = "Caller Satisfaction",
                     breaks = 1:5,
                     limits = c(1, 5)) +
  ggtitle("2020 Caller Satisfaction")
```

:::






## Glossary {#glossary-viz}

`r glossary_table()`

## Further Resources {#resources-viz}

* [Data visualisation using R, for researchers who don't use R](https://psyteachr.github.io/introdataviz/) [@nordmann_2021]
* [Chapter 3: Data Visualisation](http://r4ds.had.co.nz/data-visualisation.html) of *R for Data Science*
* [ggplot2 cheat sheet](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf)
* [ggplot2 FAQs](https://ggplot2.tidyverse.org/articles/)
* [Chapter 28: Graphics for communication](http://r4ds.had.co.nz/graphics-for-communication.html) of *R for Data Science*
* [Look at Data](http://socviz.co/look-at-data.html) from [Data Vizualization for Social Science](http://socviz.co/)
* [Hack Your Data Beautiful](https://psyteachr.github.io/hack-your-data/) workshop by University of Glasgow postgraduate students
* [Graphs](http://www.cookbook-r.com/Graphs) in *Cookbook for R*
* [ggplot2 documentation](https://ggplot2.tidyverse.org/reference/)
* [The R Graph Gallery](http://www.r-graph-gallery.com/) (this is really useful)
* [Top 50 ggplot2 Visualizations](http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html)
* [R Graphics Cookbook](http://www.cookbook-r.com/Graphs/) by Winston Chang
* [ggplot extensions](https://www.ggplot2-exts.org/)
* [plotly](https://plot.ly/ggplot2/) for creating interactive graphs
