# Data Tidying {#tidy}

## Intended Learning Outcomes {#ilo-tidy}

* Be able to change data between long and wide formats
* Separate, mutate, rename column headers and category labels


## Pipes {#pipes}

<div style="width: 200px; float: right;"><img src="images/pipe_sticker.png" style="width: 100%" /></div>

Pipes are a way to order your code in a more readable format. 

Let's say you have a [small Excel table](data/widgets_gadgets.xlsx) with 10 customer IDs, and how many widgets and gadgets each purchased in 2020 and 2021. You want to calculate the total number of items purchased per year make a table sorted by the total number of  items purchased.

```{r, echo = FALSE}
set.seed(90210)
data_original <- tibble(
  customer_id = 1:10,
  widgets_2020 = sample(0:6, 10, T),
  widgets_2021 = sample(0:6, 10, T),
  gadgets_2020 = sample(0:6, 10, T),
  gadgets_2021 = sample(0:6, 10, T)
)

kable(data_original, col.names = c("Customer ID", "2020", "2021", "2020", "2021")) %>%
  add_header_above(c(" " = 1, "Widgets" = 2, "Gadgets" = 2))
```


One way you could do this is by creating a new object at every step and using that object in the next step. This is pretty clear, but you've created several unnecessary data objects in your environment. This can get confusing in very long scripts. 

```{r no-pipe-example}

# get the data with better column names
data_original <- readxl::read_excel(
  path = "data/widgets_gadgets.xlsx", 
  skip = 2,
  col_names = c("customer_id", 
                "widgets_2020", 
                "widgets_2021", 
                "gadgets_2020", 
                "gadgets_2021")
)

# gather columns 2 to 5 into "item_year" and "number" columns
data_gathered <- gather(data = data_original, 
                        key = item_year, 
                        value = number, 2:5)

# separate the item_year column at the _ into "item" and "year" columns
data_separated <- separate(data = data_gathered, 
                           col = item_year, 
                           into = c("item", "year"), 
                           sep = "_")

# group the data by item and year
data_grouped <- group_by(.data = data_separated, item, year)

# calculate the total number for each item/year 
data_summarised <- summarise(.data = data_grouped, 
                             year_total = sum(number), 
                             .groups = "drop")

# spread the year_total column into columns by year
data_spread <- spread(data = data_summarised, 
                      key = year, 
                      value = year_total)

```

::: {.warning data-latex=""}
You *can* name each object `data` and keep replacing the old data object with the new one at each step. This will keep your environment clean, but I don't recommend it because it makes it too easy to accidentally run your code out of order when you are running line-by-line for development or debugging.
:::

One way to avoid extra objects is to nest your functions, literally replacing each data object with the code that generated it in the previous step. This can be fine for very short chains.

```{r ok-chain}
mean_petal_width <- round(mean(iris$Petal.Width), 2)
```

But it gets extremely confusing for long chains:

```{r no-pipe-example-very-bad}
# do not ever do this!!
data <- spread(
  data = summarise(
    .data = group_by(
      .data = separate(
        data = gather(
          data = readxl::read_excel(
            path = "data/widgets_gadgets.xlsx", 
            skip = 2,
            col_names = c("customer_id", 
                          "widgets_2020", 
                          "widgets_2021", 
                          "gadgets_2020", 
                          "gadgets_2021")), 
          key = item_year, value = number, 2:5), 
        item_year, c("item", "year"), sep = "_"), 
      item, year), 
    year_total = sum(number), .groups = "drop"),
  key = year, value = year_total)
```

The pipe lets you "pipe" the result of each function into the next function, allowing you to put your code in a logical order without creating too many extra objects.

```{r pipe-example}
data <- readxl::read_excel(
  path = "data/widgets_gadgets.xlsx", 
  skip = 2,
  col_names = c("customer_id", 
                "widgets_2020", 
                "widgets_2021", 
                "gadgets_2020", 
                "gadgets_2021")
) %>%
  gather(key = item_year, value = number, 2:5) %>%
  separate(col = item_year, into = c("item", "year"), sep = "_") %>%
  group_by(item, year) %>%
  summarise(year_total = sum(number), .groups = "drop") %>%
  spread(key = year, value = year_total)
```

You can read this code from top to bottom as follows:

1. Read in an excel file 
    - at the *path* `r path("data/widgets_gadgets.xlsx")`
    - *skip*ping the first two rows,
    - with new *col*umn *names*; **and then**
2. Gather to create a *key* column `item_year` and *value* column `number` from columns 2 to 5; **and then**
3. Separate the *col*umn `item_year` *into* 2 new columns called `item` and `year`, *sep*arate at the "_"; **and then**
4. Group by columns `item` and `year`; **and then**
5. Summarise and new column called `year_total` as the sum of the `number` column for each group and drop *groups*; **and then**
6. Mutate the table to add a new column called `total` that is the sum of the `year_total` column for each group; **and then**
6. Spread to make new columns with the *key* names in `year` and *value*s in `year_total`

You can make intermediate objects whenever you need to break up your code because it's getting too complicated or if you need to debug something.

::: {.info data-latex=""}
You can debug a pipe by highlighting from the beginning to just before the pipe you want to stop at. Try this by highlighting from `data <-` to the end of the `separate` function and typing cmd-return. What does `data` look like now?
:::
