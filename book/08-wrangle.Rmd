# Data Wrangling {#wrangle}

## Intended Learning Outcomes {#ilo-wrangle}

* Be able to select and filter data for relevance
* Be able to create new columns and edit existing ones

```{r setup-wrangle, message=FALSE}
library(tidyverse)   # data wrangling functions
library(lubridate)   # for handling dates and times
```

## Wrangling functions

Most `r glossary("data wrangling")` involves the reshaping functions you learned in Chapter\ \@ref(tidy) and these six functions: `select`, `filter`, `arrange`, `mutate`, `summarise`, and `group_by`. We'll cover the first four in this chapter, and the last two in Chapter\ \@ref(summary).

```{r, echo = FALSE}
set.seed(8675309)
budget <- faux::sim_design(
  between = list(
    region = c("North", "South", "East", "West"),
    product = c("widgets", "gadgets")
  ),
  within = list(
    type = c("sales", "expenses"),
    year = 2019:2020
  ),
  n = 1,
  mu = rep(c(10000, 5000), each = 4, times = 4),
  sd = 1000,
  plot = FALSE
) %>%
  mutate_if(is.numeric, round) %>%
  select(-id)

write_csv(budget, "data/budget.csv")
```

We'll use a small example table with the sales and expenses for two years from four regions over two products.

```{r}
budget <- read_csv("data/budget.csv", show_col_types = FALSE)
```

```{r, echo = FALSE}
budget
```


### Select

Select columns by name or number.

You can select each column individually, separated by commas (e.g., `region, sales_2019`). You can also select all columns between two columns by separating them with a colon (e.g., `sales_2019:expenses_2020`).

```{r select-name}
budget2020 <- budget %>% select(region, sales_2020, expenses_2020)
names(budget2020)
```

You can select columns by number, which is useful when the column names are long or complicated.

```{r select-number}
regions <- budget %>% select(1, 3:6)
names(regions)
```

You can use a minus symbol to unselect columns, leaving all of the other columns. If you want to exclude a span of columns, put parentheses around the span first, e.g., `-(sales_2019:expenses_2020)`, not `-sales_2019:expenses_2020`.

```{r select-unselect}
sales <- budget %>% select(-(expenses_2019:expenses_2020))
names(sales)
```

You can select columns based on criteria about the column names.

| function | definition |
|----------|------------|
| `starts_with()` | select columns that start with a character string|
| `ends_with()` | elect columns that end with a character string |
| `contains()` | select columns that contain a character string |
| `num_range()` | select columns with a name that matches the pattern `prefix` |

::: {.info data-latex=""}
Use `width` to set the number of digits with leading
zeros. For example, `num_range('var_', 8:10, width=2)` selects columns `var_08`, `var_09`, and `var_10`.
:::

```{r select-helpers, echo = FALSE}
x1 <- budget %>% select(starts_with("sales"))
x2 <- budget %>% select(ends_with("2020"))
x3 <- budget %>% select(contains("_"))
x4 <- budget %>% select(num_range("expenses_", 2019:2020))

a <- list(names(x1), names(x2), names(x3), names(x4)) %>%
  sapply(paste, collapse = ", ")

a1 <- setNames(a, c("answer", "x", "x", "x")) %>% sample() %>% mcq()
a2 <- setNames(a, c("x", "answer", "x", "x")) %>% sample() %>% mcq()
a3 <- setNames(a, c("x", "x", "answer", "x")) %>% sample() %>% mcq()
a4 <- setNames(a, c("x", "x", "x", "answer")) %>% sample() %>% mcq()
```


::: {.try data-latex=""}
What are the resulting columns for these four examples?

* `budget %>% select(starts_with("sales"))`
    `r a1` 
* `budget %>% select(ends_with("2020"))`
    `r a2`
* `budget %>% select(contains("_"))`
    `r a3`
* `budget %>% select(num_range("expenses_", 2019:2020))`
    `r a4`
:::



### Filter

Select rows by matching column criteria.

```{r filter}
# select all rows from the North region
budget %>% filter(region == "North")
```

::: {.warning data-latex=""}
Remember to use `==` and not `=` to check if two things are equivalent. A single `=` assigns the righthand value to the lefthand variable and (usually) evaluates to `TRUE`.
:::

You can select on multiple criteria by separating them with commas.

```{r filter-multiple}
budget %>% filter(
  region == "North",
  product == "widgets"
)
```

You can use the symbols `&`, `|`, and `!` to mean "and", "or", and "not". You can also use other operators to make equations. The equation is checked for each row, and if the result is FALSE, the row is removed.

```{r filter-symbols}
# regions and products with profit in both 2019 and 2020
profit_both <- budget %>% 
  filter(
    sales_2019 > expenses_2019 &
    sales_2020 > expenses_2020
  )

# regions and products with profit in 2019 or 2020
profit_either <- budget %>% 
  filter(
    sales_2019 > expenses_2019 |
    sales_2020 > expenses_2020
  )

# everything but the North
not_north <- budget %>%
  filter(region != "North")

# 2020 profit greater than 1000
profit_1000 <- budget %>%
  filter(sales_2020 - expenses_2020 > 1000)

```

The `r glossary("match operator")` (`%in%`) is useful here for testing if a column value is in a list.

```{r match-operator}
budget %>%
  filter(region %in% c("North", "South") &
           product == "widgets")
```


### Arrange

Sort your dataset using `arrange()`. You will find yourself needing to sort data in R much less than you do in Excel, since you don't need to have rows next to each other in order to, for example, calculate group means. But `arrange()` can be useful when preparing data for display in tables. Reverse the order using `desc()`.

```{r arrange}
budget %>%
  arrange(product, desc(region))
```


::: {.try data-latex=""}
If you want to sort categories in a specific order, turn the column into a `r glossary("factor")` and set the `levels` in the desired order.

```{r}
budget %>%
  mutate(region = factor(region, levels = c("North", "South", "East", "West"))) %>%
  filter(product == "gadgets") %>%
  arrange(region)
```

:::

### Mutate

Add new columns or change existing ones. Refer to other columns by their names (unquoted). You can add more than one column in the same mutate function, just separate the columns with a comma. Once you make a new column, you can use it in further column definitions e.g., `profit` below).

```{r mutate}
budget2 <- budget %>%
  mutate(
    sales = sales_2019 + sales_2020,
    expenses = expenses_2019 + expenses_2020,
    profit = sales - expenses,
    region = paste(region, "Office")
  )
```


::: {.warning data-latex=""}
You can overwrite a column by giving a new column the same name as the old column (see `region`) above. Make sure that you mean to do this and that you aren't trying to use the old column value after you redefine it.
:::


Load some data about the population of the Scottish counties. 

```{r}
scotpop <- read_csv("data/scottish_population.csv",
                    show_col_types = FALSE)
```

Transform the population value to the nearest thousands (e.g., 3433 would be "3K"), order from most to least populous, put the columns in the order `population` (in K) then `county`, and show only the counties with populations greater than 200K. 

```{r, echo = FALSE}
scotpop %>%
  arrange(desc(population)) %>%
  filter(population > 200000) %>%
  mutate(kpop = round(population/1000) %>% paste0("K")) %>%
  select(population = kpop, 
         county = name)
```

::: {.try data-latex=""}
There are several different ways you could make the table above. Some functions could be in a different order and some couldn't. See where you can move the `filter()` and `arrange()` functions.
:::

```{r, eval = FALSE, webex.hide = TRUE}
scotpop %>%
  arrange(desc(population)) %>%
  filter(population > 200000) %>%
  mutate(kpop = round(population/1000) %>% paste0("K")) %>%
  select(population = kpop, 
         county = name)
```

## Putting it together {#together-wrangle}

Load some demo data we first used in Chapter\ \@ref(data). Use `glimpse()` or another method to get familiar with the data set.

```{r}
# from https://www.kaggle.com/kyanyoga/sample-sales-data
sales <- read_csv("data/sales_data_sample.csv",
                  show_col_types = FALSE)
```


Double check that the `SALES` column does equal the `QUANTITYORDERED` column times the `PRICEEACH`. You can select just the columns you need and rename them when selecting to make the code more readable.

```{r}
sales_check <- sales %>%
  select(SALES, n = QUANTITYORDERED, price = PRICEEACH) %>%
  mutate(total = n * price)
```

Make a table of any rows where the value of `total` doesn't equal `SALES`.

```{r}
errors <- sales_check %>%
  filter(SALES != total)

head(errors)
```

If you check the `errors` table, you'll see that `r nrow(errors)` of the original `r nrow(sales)` rows have "errors", even though many of the values in the `SALES` and `sales_check` columns look identical. You can fix this by rounding the value of `total` to 2 decimal places.

::: {.info data-latex=""}
This is due to the way values with decimal places are represented by a computer. You use base 10 to count, and have to represent some numbers with a repeating decimal, like 1/3 is .0333 repeating, while a computer uses binary to count, and has to represent different numbers using repeats. This can lead to very small differences when you divide or multiply some numbers.

```{r}
options(scipen = 20) # avoids scientific notation
x = (1/49 * 49)
x # prints as 1
1-x # but is actually very slightly smaller
```

:::


```{r}
errors <- sales_check %>%
  filter(SALES != round(total, 2))
```

There are still `r nrow(errors)` errors! Lets look at the 10 smallest. We can do this by calculating the difference, arranging from smallest to largest, and filtering for the first 10 rows. 

```{r, eval = FALSE}
errors %>%
  mutate(diff = SALES - total) %>%
  arrange(diff) %>%
  filter(row_number() <= 10)
```

Alternatively, we can use a `slice` function.

```{r}
errors %>%
  mutate(diff = SALES - total) %>%
  slice_min(order_by = diff, n = 10)
```

If we plot the data, it looks like all of the errors are in one direction.

```{r}
ggplot(errors, aes(x = SALES, y = total)) + 
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0) +
  coord_cartesian(xlim = c(0, 15000), ylim = c(0, 8000))
```

Let's have a look at the data separately for products with a price of exactly 100 versus other products.

```{r}
sales_check %>%
  mutate(price100 = price == 100) %>%
  ggplot(aes(x = SALES, y = total, color = price100)) + 
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0) +
  coord_cartesian(xlim = c(0, 15000), ylim = c(0, 8000))
```

It looks like that's the problem with this dataset: the `PRICEEACH` column doesn't go above 100. Let's fix that by dividing the total sale price by the quantity ordered.

```{r}
fixed_sales <- sales %>%
  mutate(PRICEEACH = round(SALES / QUANTITYORDERED, 2))
```

Now we can re-run the code from before to find any errors. 

```{r}
sales_check <- fixed_sales %>%
  select(SALES, n = QUANTITYORDERED, price = PRICEEACH) %>%
  mutate(total = n * price)

errors <- sales_check %>%
  filter(SALES != round(total, 2))

head(errors)
```

There are 5 instances where the quantity ordered doesn't divide into the total price in a way that produces prices that round to the nearest cent. These might require further investigation.

## Glossary {#glossary-wrangle}

`r glossary_table()`

## Further resources {#resources-wrangle}

* [Data transformation cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf)
* [Chapter 5: Data Transformation ](http://r4ds.had.co.nz/transform.html) in *R for Data Science*


