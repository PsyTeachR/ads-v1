[{"path":"index.html","id":"overview","chapter":"Overview","heading":"Overview","text":"book provides overview basic skills needed turn raw data informative summaries visualisations presented professional reports presentations. book introduce learners R (R Core Team, 2021), programming language can help automate working data. book cover importing processing data spreadsheets, producing data summaries descriptive statistics tables, creating beautiful informative visualisations, constructing reports presentations automatically update underlying data changes.end book, able use R :clean process datasummarise datainformatively visualise datacreate reusable report templates","code":""},{"path":"index.html","id":"structure-of-the-course","chapter":"Overview","heading":"0.1 Structure of the course","text":"book accompanies 10-week course, covering one chapter per week. chapter introduce new skills concepts using concrete examples. various points, multiple-choice fill---blank questions check understanding. chapter accompanying walk-videos, instructor demonstrates skills covered chapter. chapter also accompanying exercises reinforce learning.","code":""},{"path":"index.html","id":"how-to-learn-data-skills","chapter":"Overview","heading":"0.2 How to learn data skills","text":"Learning data skills kind like gym membership (thanks Phil McAleer analogy). given state---art equipment use instructions use , data skills get stronger unless practice.Data skills require memorise lots code. introduced many different functions, main skill learn efficiently find information need. require getting used structure help files cheat sheets, learning Goggle problem choose helpful solution, learning read error messages.Learning code involves making lot mistakes. mistakes completely essential process, try feel frustrated. Many chapter exercises give broken code fix get experience seeing common errors look like. become experienced coder, might make fewer errors, recover much faster.","code":""},{"path":"joins.html","id":"joins","chapter":"1 Data Relations","heading":"1 Data Relations","text":"","code":""},{"path":"joins.html","id":"ilo-joins","chapter":"1 Data Relations","heading":"1.1 Intended Learning Outcomes","text":"able match related data across multiple tablesBe able combine data multiple files","code":""},{"path":"joins.html","id":"set-up","chapter":"1 Data Relations","heading":"1.2 Set-up","text":"First, create new project work chapter named 06-relations. Second, open save new R Markdown document named relations.Rmd`, delete welcome text, load required packages chapter.","code":"```{r setup, include=FALSE}\nlibrary(tidyverse)     # includes readr & tibble```"},{"path":"joins.html","id":"joins-data","chapter":"1 Data Relations","heading":"1.3 Loading data","text":"data want report visualise often one file (one tab excel file googlesheet). might need join table customer information table orders, combine monthly social media reports across several months.demo, rather loading data, create two small data tables scratch using tibble() function.customers id, city postcode five customers 1-5.1:5 fill variable id integers 1 5.city code use c() function enter multiple strings. Note entry contained within quotation marks, apart missing data, recorded NA.entering data like , important order variable matches . number 1 correspond \"Port Ellen\" \"PA42 7DU\".\nTable 1.1: Demo customers table.\norders customer id number items ordered. customers previous table orders, one order, customer table.\nTable 1.2: Demo orders table.\n","code":"\ncustomers <- tibble(\n  id = 1:5,\n  city = c(\"Port Ellen\", \"Dufftown\", NA, \"Aberlour\", \"Tobermory\"),\n  postcode = c(\"PA42 7DU\", \"AB55 4DH\", NA, \"AB38 7RY\", \"PA75 6NR\")\n)\norders <- tibble(\n  id = c(2, 3, 4, 4, 5, 5, 6, 6, 7),\n  items = c(10, 18, 21, 23, 9, 11, 11, 12, 3)\n)"},{"path":"joins.html","id":"mutating-joins","chapter":"1 Data Relations","heading":"1.4 Mutating Joins","text":"Mutating joins act like dplyr::mutate() function add new columns one table based values another table. (learn mutate() function Chapter ??.)mutating joins basic syntax:****_join(x, y, = NULL, suffix = c(\".x\", \".y\"))x = first (left) tabley = second (right) tableby = columns match . leave blank, match columns names two tables.suffix = columns name two tables, joining , get suffix make unambiguous. defaults \".x\" \".y\", can change something meaningful.can leave argument matching columns name, good practice always specify code robust changes loaded data.","code":""},{"path":"joins.html","id":"left_join","chapter":"1 Data Relations","heading":"1.4.1 left_join()","text":"left_join keeps data first (left) table adds anything matches second (right) table. right table one match row left table, one row joined table (see ids 4 5).order specify tables matters, code reversed order result rows orders table joined matching rows customers table.","code":"\nleft_data <- left_join(customers, orders, by = \"id\")\nleft_data\nleft2_data <- left_join(orders, customers, by = \"id\")\nleft2_data"},{"path":"joins.html","id":"right_join","chapter":"1 Data Relations","heading":"1.4.2 right_join()","text":"right_join keeps data second (right) table joins anything matches first (left) table.table information left_join(orders, customers, = \"id\"), columns different order (left table, right table).","code":"\nright_data <- right_join(customers, orders, by = \"id\")\nright_data"},{"path":"joins.html","id":"inner_join","chapter":"1 Data Relations","heading":"1.4.3 inner_join()","text":"inner_join returns rows match tables. Changing order tables change order columns, rows kept.","code":"\ninner_data <- inner_join(customers, orders, by = \"id\")\ninner_data"},{"path":"joins.html","id":"full_join","chapter":"1 Data Relations","heading":"1.4.4 full_join()","text":"full_join lets join rows two tables keeping information tables. row match table, table's column values set NA.","code":"\nfull_data <- full_join(customers, orders, by = \"id\")\nfull_data"},{"path":"joins.html","id":"filtering-joins","chapter":"1 Data Relations","heading":"1.5 Filtering Joins","text":"Filtering joins act like dplyr::filter() function keep remove rows data one table based values another table. result filtering join contain rows left table number fewer rows left table. (learn filter() function Chapter ??.)","code":""},{"path":"joins.html","id":"semi_join","chapter":"1 Data Relations","heading":"1.5.1 semi_join()","text":"semi_join returns rows left table matching values right table, keeping just columns left table.Unlike inner join, semi join never duplicate rows left table one matching row right table.Order matters semi join.","code":"\nsemi_data <- semi_join(customers, orders, by = \"id\")\nsemi_data\nsemi2_data <- semi_join(orders, customers, by = \"id\")\nsemi2_data"},{"path":"joins.html","id":"anti_join","chapter":"1 Data Relations","heading":"1.5.2 anti_join()","text":"anti_join return rows left table matching values right table, keeping just columns left table.Order matters anti join.","code":"\nanti_data <- anti_join(customers, orders, by = \"id\")\nanti_data\nanti2_data <- anti_join(orders, customers, by = \"id\")\nanti2_data"},{"path":"joins.html","id":"multiple-joins","chapter":"1 Data Relations","heading":"1.6 Multiple joins","text":"****_join() functions two-table verbs, , can join together two tables time. However, may often need join together multiple tables. , simply need add additional joins. can creating intermediate object efficiently using pipe.every stage analysis check output ensure created intended create, particularly true joins. familiar enough data routine checks using functions like glimpse(), str(), summary() rough idea join result . least, know whether joined object result fewer variables observations.multi-line join like piped example, build code check output stage.","code":"\n# create a table of overall customer satisfaction scores\nsatisfaction <- tibble(\n  id = 1:5,\n  satisfaction = c(4, 3, 2, 3, 1)\n)\n\n# perform the initial join\njoin_1 <- left_join(customers, orders, by = \"id\")\n\n# perform the second join on the new object\njoin_2 <- left_join(join_1, satisfaction, \n                    by = \"id\")\n# more efficient method using the pipe\npipe_join <- customers %>%\n  left_join(orders, by = \"id\") %>%\n  left_join(satisfaction, by = \"id\")"},{"path":"joins.html","id":"binding-joins","chapter":"1 Data Relations","heading":"1.7 Binding Joins","text":"Binding joins bind one table another adding rows columns together.","code":""},{"path":"joins.html","id":"bind_rows","chapter":"1 Data Relations","heading":"1.7.1 bind_rows()","text":"can combine rows two tables bind_rows.add customer data customers 6-9 bind original customer table.columns just names, order. columns differ two tables just NA values entries table.row duplicated two tables (like id 5 ), row also duplicated resulting table. tables exact columns, can use union() (see Section 1.8.2) avoid duplicates.","code":"\nnew_customers <- tibble(\n  id = 6:9,\n  city = c(\"Falkirk\", \"Ardbeg\", \"Doogal\", \"Kirkwall\"),\n  postcode = c(\"FK1 4RS\", \"PA42 7EA\", \"G81 4SJ\", \"KW15 1SE\")\n)\n\nbindr_data <- bind_rows(customers, new_customers)\nbindr_data\nnew_customers <- tibble(\n  id = 5:9,\n  postcode = c(\"PA75 6NR\", \"FK1 4RS\", \"PA42 7EA\", \"G81 4SJ\", \"KW15 1SE\"),\n  city = c(\"Tobermory\", \"Falkirk\", \"Ardbeg\", \"Doogal\", \"Kirkwall\"),\n  new = c(1,2,3,4,5)\n)\n\nbindr2_data <- bind_rows(customers, new_customers)\nbindr2_data"},{"path":"joins.html","id":"bind_cols","chapter":"1 Data Relations","heading":"1.7.2 bind_cols()","text":"can merge two tables number rows using bind_cols. useful two tables number rows exact order.advantage bind_cols() mutating join tables IDs join rely solely order. Otherwise, use mutating join (four mutating joins result output rows table exactly one match table).","code":"\nnew_info <- tibble(\n  colour = c(\"red\", \"orange\", \"yellow\", \"green\", \"blue\")\n)\n\nbindc_data <- bind_cols(customers, new_info)\nbindc_data "},{"path":"joins.html","id":"importing-multiple-files","chapter":"1 Data Relations","heading":"1.7.3 Importing multiple files","text":"need import bind whole folder full files structure, get list files want combine. easiest directory, although can use pattern select files want systematic naming structure.First, save two customer tables CSV files. dir.create() function makes folder called \"data\". showWarnings = FALSE argument means get warning folder already exists, just anything.Next, retrieve list file names data folder contain string \"customers\"Next, iterate list read data file. Whilst something cover detail core resources course, iteration important concept know . Iteration perform task multiple different inputs. general rule thumb, find copying pasting thing twice, efficient less error-prone way , although functions typically require stronger grasp programming.purrr package contains functions help iteration. purrr::map_df() maps function list returns data frame (table) results..x list file paths.f specifies function map file paths.resulting object all_files data frame combines files together, similar imported separately used bind_rows(). Note map_df() work way structure files identical.","code":"\n# write our data to a new folder for the demo\ndir.create(\"data\", showWarnings = FALSE)\nwrite_csv(x = customers, file = \"data/customers1.csv\")\nwrite_csv(x = new_customers, file = \"data/customers2.csv\")\nfiles <- list.files(\n  path = \"data\", \n  pattern = \"customers\", \n  full.names = TRUE\n)\n\nfiles## [1] \"data/customers1.csv\" \"data/customers2.csv\"\nall_files <- purrr::map_df(.x = files, .f = read_csv)"},{"path":"joins.html","id":"set-operations","chapter":"1 Data Relations","heading":"1.8 Set Operations","text":"Set operations compare two tables return rows match (intersect), either table (union), one table (setdiff).","code":""},{"path":"joins.html","id":"intersect","chapter":"1 Data Relations","heading":"1.8.1 intersect()","text":"dplyr::intersect() returns rows two tables match exactly. columns order, names.forgotten load dplyr tidyverse, base R also base::intersect() function work like dplyr::intersect(). error message can confusing looks something like :","code":"\nnew_customers <- tibble(\n  id = 5:9,\n  postcode = c(\"PA75 6NR\", \"FK1 4RS\", \"PA42 7EA\", \"G81 4SJ\", \"KW15 1SE\"),\n  city = c(\"Tobermory\", \"Falkirk\", \"Ardbeg\", \"Doogal\", \"Kirkwall\")\n)\n\nintersect_data <- intersect(customers, new_customers)\nintersect_data\nbase::intersect(customers, new_customers)## Error: Must subset rows with a valid subscript vector.\n## ℹ Logical subscripts must match the size of the indexed input.\n## x Input has size 5 but subscript `!duplicated(x, fromLast = fromLast, ...)` has size 0."},{"path":"joins.html","id":"union","chapter":"1 Data Relations","heading":"1.8.2 union()","text":"dplyr::union() returns rows tables, removing duplicate rows, unlike bind_rows().forgotten load dplyr tidyverse, base R also base::union() function. usually get error message, output expect.","code":"\nunion_data <- union(customers, new_customers)\nunion_data\nbase::union(customers, new_customers)## [[1]]\n## [1] 1 2 3 4 5\n## \n## [[2]]\n## [1] \"Port Ellen\" \"Dufftown\"   NA           \"Aberlour\"   \"Tobermory\" \n## \n## [[3]]\n## [1] \"PA42 7DU\" \"AB55 4DH\" NA         \"AB38 7RY\" \"PA75 6NR\"\n## \n## [[4]]\n## [1] 5 6 7 8 9\n## \n## [[5]]\n## [1] \"PA75 6NR\" \"FK1 4RS\"  \"PA42 7EA\" \"G81 4SJ\"  \"KW15 1SE\"\n## \n## [[6]]\n## [1] \"Tobermory\" \"Falkirk\"   \"Ardbeg\"    \"Doogal\"    \"Kirkwall\""},{"path":"joins.html","id":"setdiff","chapter":"1 Data Relations","heading":"1.8.3 setdiff()","text":"dplyr::setdiff returns rows first table, second table.Order matters setdiff.forgotten load dplyr tidyverse, base R also base::setdiff() function. usually get error message, output might expect base::setdiff() expects columns order, id 5 registers different two tables.","code":"\nsetdiff_data <- setdiff(customers, new_customers)\nsetdiff_data\nsetdiff2_data <- setdiff(new_customers, customers)\nsetdiff2_data\nbase::setdiff(customers, new_customers)"},{"path":"joins.html","id":"conflicting-variable-types","chapter":"1 Data Relations","heading":"1.9 Conflicting variable types","text":"covered Chapter ??, import create data, R best set column appropriate data type. However, sometimes gets wrong sometimes something way data encoded original spreadsheet causes data type different expected. joining datasets common columns, important variable names identical, data type variables identical.recreate new_customers dataset time, specify id character character variable.try join dataset datasets id stored numeric variable, produce error.goes bind_rows():alternative method change variable types showed Chapter ?? use .*** functions. type . code chunk, see huge number functions transforming variables datasets different types. Exactly one need depend data , commonly used ones :.numeric() - convert variable numeric. Useful variable real numbers encoded character. values turned numbers (e.g., word \"missing\" cells data ), returned NA..factor() - convert variable factor. can set factor levels labels manually, use default order (alphabetical)..character() - convert variable character data..tibble() .data.frame() - convert object tibble data frame. actually relevant discussing , useful one aware sometimes run issues get error specifically requests data tibble data frame type can use function overwrite object.use functions variable can use mutate() overwrite variable variable new data type:done , joins now work:","code":"\nnew_customers2 <- tibble(\n  id = as.character(5:9),\n  postcode = c(\"PA75 6NR\", \"FK1 4RS\", \"PA42 7EA\", \"G81 4SJ\", \"KW15 1SE\"),\n  city = c(\"Tobermory\", \"Falkirk\", \"Ardbeg\", \"Doogal\", \"Kirkwall\")\n)\nstr(new_customers2)## tibble [5 × 3] (S3: tbl_df/tbl/data.frame)\n##  $ id      : chr [1:5] \"5\" \"6\" \"7\" \"8\" ...\n##  $ postcode: chr [1:5] \"PA75 6NR\" \"FK1 4RS\" \"PA42 7EA\" \"G81 4SJ\" ...\n##  $ city    : chr [1:5] \"Tobermory\" \"Falkirk\" \"Ardbeg\" \"Doogal\" ...\ninner_join(customers, new_customers2)## Joining, by = c(\"id\", \"city\", \"postcode\")## Error: Can't join on `x$id` x `y$id` because of incompatible types.\n## ℹ `x$id` is of type <integer>>.\n## ℹ `y$id` is of type <character>>.\nbind_rows(customers, new_customers2)## Error: Can't combine `..1$id` <integer> and `..2$id` <character>.\nnew_customers2 <- new_customers2 %>%\n  mutate(id = as.numeric(id))\ninner_join(orders, new_customers2)## Joining, by = \"id\""},{"path":"joins.html","id":"exercises","chapter":"1 Data Relations","heading":"1.10 Exercises","text":"lots different use cases ****_join() functions. exercises allow practice different joins. examples joins might helpful work, please post Teams week 6 channel, many concrete examples can help distinguish different joins.","code":""},{"path":"joins.html","id":"grade-data","chapter":"1 Data Relations","heading":"1.10.1 Grade data","text":"University Glasgow's Schedule grading scheme uses 22-point alphanumeric scale (information summative report assessment information sheet). alphanumeric grade (e.g., B2) underlying numeric Grade Point (e.g., 16).Often working student grades provided us one forms, need able go two. example, need numeric form order able calculate descriptive statistics mean grade, need alphanumeric form release student records.Download,andinto data folder.Read scheduleA.csv save object named schedule.Read grade_data1.csv save object named grades1.Read grade_data2.csv save object named grades2.","code":"\nschedule <- read_csv(\"data/scheduleA.csv\")## Rows: 23 Columns: 2## ── Column specification ────────────────────────────────────────────────────────\n## Delimiter: \",\"\n## chr (1): Grade\n## dbl (1): Points## \n## ℹ Use `spec()` to retrieve the full column specification for this data.\n## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\ngrades1 <- read_csv(\"data/grade_data1.csv\") ## Rows: 100 Columns: 3## ── Column specification ────────────────────────────────────────────────────────\n## Delimiter: \",\"\n## chr (2): assessment, id\n## dbl (1): Points## \n## ℹ Use `spec()` to retrieve the full column specification for this data.\n## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\ngrades2 <- read_csv(\"data/grade_data2.csv\")## Rows: 100 Columns: 3## ── Column specification ────────────────────────────────────────────────────────\n## Delimiter: \",\"\n## chr (1): assessment\n## dbl (2): id, Points## \n## ℹ Use `spec()` to retrieve the full column specification for this data.\n## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."},{"path":"joins.html","id":"matching-the-variable-types","chapter":"1 Data Relations","heading":"1.10.2 Matching the variable types","text":"UofG, students given GUID, numeric ID number. However, ID number also combined first letter surname create username used email address. example, ID 1234567 surname Nordmann, username 1234567n. data wrangling perspective annoying numeric ID stored numeric data, username stored character letter end. grades1 numeric id whilst grades2 additional letter. order join datasets, need standardise variables.First, remove letter character id using function str_sub() returns subset string.Now, transform data type id matches data type grades2.","code":"\ngrades1 <- grades1 %>%\n  mutate(id = str_sub(id, # the variable you want to subset\n                      start = 1, # when the subset should start, in this case, the 1st character\n                      end = nchar(id)-1)) # when the subset should end, in this case, 1 less than the number of characters \nstr(grades1)\nstr(grades2) # check variable types\ngrades1 <- grades1 %>%\n  mutate(id = as.numeric(id))## spec_tbl_df [100 × 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##  $ assessment: chr [1:100] \"Exam\" \"Exam\" \"Exam\" \"Exam\" ...\n##  $ id        : chr [1:100] \"1\" \"2\" \"3\" \"4\" ...\n##  $ Points    : num [1:100] NA 16 12 15 16 NA 16 13 15 NA ...\n##  - attr(*, \"spec\")=\n##   .. cols(\n##   ..   assessment = col_character(),\n##   ..   id = col_character(),\n##   ..   Points = col_double()\n##   .. )\n##  - attr(*, \"problems\")=<externalptr> \n## spec_tbl_df [100 × 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##  $ id        : num [1:100] 1 2 3 4 5 6 7 8 9 10 ...\n##  $ Points    : num [1:100] 12 16 15 NA 14 NA 8 NA 16 14 ...\n##  $ assessment: chr [1:100] \"Essay\" \"Essay\" \"Essay\" \"Essay\" ...\n##  - attr(*, \"spec\")=\n##   .. cols(\n##   ..   id = col_double(),\n##   ..   Points = col_double(),\n##   ..   assessment = col_character()\n##   .. )\n##  - attr(*, \"problems\")=<externalptr>"},{"path":"joins.html","id":"complete-records","chapter":"1 Data Relations","heading":"1.10.3 Complete records","text":"example, want join grade data schedule student grade grade grade point. , also want complete record students course students missing grades still included data.Join grades1 scheduleA store table object named exam_all. TDo grades2 save essay_grades.exam_grades essay_all 100 observations 4 variables.want keep data grade_data1 grade_data2 want alphanumeric grades schedule Grade Point values exist grades. E.g., -one awarded F1, final dataset .","code":"\nexam_all <- left_join(grades1, schedule, by = \"Points\")\nessay_all <- left_join(grades2, schedule, by = \"Points\")"},{"path":"joins.html","id":"missing-data","chapter":"1 Data Relations","heading":"1.10.4 Missing data","text":"Alternatively, may wish dataset contains data students submitted assessment grade. First, run summary() exam_all essay_all.many exam grades missing? many essay grades missing? Now, create object exam_grades joins together grades1 schedule time resulting object contain data students grade. grades2 store essay_grades., given know many data points missing data set:many observations essay_grades ? many observations essay_grades ? worth noting reality actually go back raw data another join get dataset, just remove missing response adding %>% drop_na() exam_all essay_all. However, reality purposes teaching joins slightly artificial way.Now, create dataset completes joins grades students grade essay exam.exam_grade essay_grade variables Points named different data, amend suffix resulting variables named Points_exam Points_essay etc. may need consult help documentation see example figure .Clean file select() keep variables id, Grade_exam, Grade_essayHow many students grade exam essay? Now create dataset no_essay contains students grade exam, essay.many students grade exam essay? Finally, now make dataset no_exam contains students grade essay examHow many students grade exam essay? ","code":"\nexam_grades <- inner_join(grades1, schedule, by = \"Points\")\nessay_grades <- inner_join(grades2, schedule, by = \"Points\")\ncompletes <- inner_join(exam_grades, essay_grades, \n                        by = \"id\", \n                        suffix = c(\"_exam\", \"_essay\")) %>%\n  select(id, Grade_exam, Grade_essay)\nno_essay <- anti_join(exam_grades, essay_grades, by = \"id\")\nno_exam <- anti_join(essay_grades,exam_grades, by = \"id\")"},{"path":"joins.html","id":"report","chapter":"1 Data Relations","heading":"1.10.5 Report","text":"final exercise chapter, create report R Markdown named Assessment Report. Assume need present report exam board likely asked following information:many students submitted assessment?average performance assessment?distribution grades assessment?preparation summative assessment, information present . done, post code knitted html document week 6 Teams channel.","code":""},{"path":"joins.html","id":"glossary-joins","chapter":"1 Data Relations","heading":"1.11 Glossary","text":"","code":""},{"path":"joins.html","id":"resources-joins","chapter":"1 Data Relations","heading":"1.12 Further resources","text":"Data transformation cheatsheetChapter 13: Relational Data R Data ScienceChapter 21: Iteration R Data Science.purrr cheatsheet","code":""}]
