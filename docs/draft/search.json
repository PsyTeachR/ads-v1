[{"path":"index.html","id":"overview","chapter":"Overview","heading":"Overview","text":"book provides overview basic skills needed turn raw data informative summaries visualisations presented professional reports presentations. book introduce learners R (R Core Team, 2021), programming language can help automate working data. book cover importing processing data spreadsheets, producing data summaries descriptive statistics tables, creating beautiful informative visualisations, constructing reports presentations automatically update underlying data changes.end book, able use R :clean process datasummarise datainformatively visualise datacreate reusable report templates","code":""},{"path":"index.html","id":"structure-of-the-course","chapter":"Overview","heading":"0.1 Structure of the course","text":"book accompanies 10-week course, covering one chapter per week. chapter introduce new skills concepts using concrete examples. various points, multiple-choice fill---blank questions check understanding. chapter accompanying walk-videos, instructor demonstrates skills covered chapter. chapter also accompanying exercises reinforce learning.","code":""},{"path":"index.html","id":"how-to-learn-data-skills","chapter":"Overview","heading":"0.2 How to learn data skills","text":"Learning data skills kind like gym membership (thanks Phil McAleer analogy). given state---art equipment use instructions use , data skills get stronger unless practice.Data skills require memorise lots code. introduced many different functions, main skill learn efficiently find information need. require getting used structure help files cheat sheets, learning Goggle problem choose helpful solution, learning read error messages.Learning code involves making lot mistakes. mistakes completely essential process, try feel frustrated. Many chapter exercises give broken code fix get experience seeing common errors look like. become experienced coder, might make fewer errors, recover much faster.","code":""},{"path":"wrangle.html","id":"wrangle","chapter":"1 Data Wrangling","heading":"1 Data Wrangling","text":"","code":""},{"path":"wrangle.html","id":"ilo-wrangle","chapter":"1 Data Wrangling","heading":"1.1 Intended Learning Outcomes","text":"able select filter data relevanceBe able create new columns edit existing onesBe able handle missing data","code":"\nlibrary(tidyverse)   # data wrangling functions"},{"path":"wrangle.html","id":"wrangling-functions","chapter":"1 Data Wrangling","heading":"1.2 Wrangling functions","text":"data wrangling involves reshaping functions learned Chapter ?? six functions: select, filter, arrange, mutate, summarise, group_by. remember last two Chapter ??, cover briefly.use small example table sales expenses two years four regions two products.","code":"\nbudget <- read_csv(\"data/budget.csv\", show_col_types = FALSE)"},{"path":"wrangle.html","id":"select","chapter":"1 Data Wrangling","heading":"1.2.1 Select","text":"Select columns name number.can select column individually, separated commas (e.g., region, sales_2019). can also select columns one another separating colon (e.g., sales_2019:expenses_2020).can select columns number, can useful column names long complicated. even rename setting new_name = old_col.can use minus symbol un-select columns, leaving columns. want exclude span columns, put parentheses around span first, e.g., -(sales_2019:expenses_2020), -sales_2019:expenses_2020.can select columns based criteria column names.Use width set number digits leading\nzeros. example, num_range('var_', 8:10, width=2) selects columns var_08, var_09, var_10.resulting columns four examples?budget %>% select(starts_with(\"sales\"))\nsales_2019, sales_2020sales_2020, expenses_2020expenses_2019, expenses_2020sales_2019, sales_2020, expenses_2019, expenses_2020budget %>% select(ends_with(\"2020\"))\nexpenses_2019, expenses_2020sales_2020, expenses_2020sales_2019, sales_2020sales_2019, sales_2020, expenses_2019, expenses_2020budget %>% select(contains(\"_\"))\nsales_2019, sales_2020, expenses_2019, expenses_2020sales_2019, sales_2020expenses_2019, expenses_2020sales_2020, expenses_2020budget %>% select(num_range(\"expenses_\", 2019:2020))\nsales_2019, sales_2020, expenses_2019, expenses_2020expenses_2019, expenses_2020sales_2019, sales_2020sales_2020, expenses_2020","code":"\nbudget2020 <- budget %>% select(region, sales_2020, expenses_2020)\nnames(budget2020)## [1] \"region\"        \"sales_2020\"    \"expenses_2020\"\nregions <- budget %>% select(`Sales Region` = 1, 3:6)\nnames(regions)## [1] \"Sales Region\"  \"sales_2019\"    \"sales_2020\"    \"expenses_2019\"\n## [5] \"expenses_2020\"\nsales <- budget %>% select(-(expenses_2019:expenses_2020))\nnames(sales)## [1] \"region\"     \"product\"    \"sales_2019\" \"sales_2020\""},{"path":"wrangle.html","id":"filter","chapter":"1 Data Wrangling","heading":"1.2.2 Filter","text":"Select rows matching column criteria.Remember use == = check two things equivalent. single = assigns right-hand value left-hand variable.can select multiple criteria separating commas.can use symbols &, |, ! mean \"\", \"\", \"\". can also use operators make equations. equation checked row, result FALSE, row removed.match operator (%%) useful testing column value list.","code":"\n# select all rows from the North region\nbudget %>% filter(region == \"North\")\nbudget %>% filter(\n  region == \"North\",\n  product == \"widgets\"\n)\n# regions and products with profit in both 2019 and 2020\nprofit_both <- budget %>% \n  filter(\n    sales_2019 > expenses_2019 &\n    sales_2020 > expenses_2020\n  )\n\n# regions and products with profit in 2019 or 2020\nprofit_either <- budget %>% \n  filter(\n    sales_2019 > expenses_2019 |\n    sales_2020 > expenses_2020\n  )\n\n# everything but the North\nnot_north <- budget %>%\n  filter(region != \"North\")\n\n# 2020 profit greater than 1000\nprofit_1000 <- budget %>%\n  filter(sales_2020 - expenses_2020 > 1000)\nbudget %>%\n  filter(region %in% c(\"North\", \"South\"),\n         product == \"widgets\")"},{"path":"wrangle.html","id":"arrange","chapter":"1 Data Wrangling","heading":"1.2.3 Arrange","text":"Sort dataset using arrange(). find needing sort data R much less Excel, since need rows next order , example, calculate group means. arrange() can useful preparing data display tables. Reverse order using desc().want sort categories specific order, turn column factor set levels desired order.","code":"\nbudget %>%\n  arrange(product, desc(region))\nbudget %>%\n  mutate(region = factor(region, levels = c(\"North\", \"South\", \"East\", \"West\"))) %>%\n  filter(product == \"gadgets\") %>%\n  arrange(region)"},{"path":"wrangle.html","id":"mutate","chapter":"1 Data Wrangling","heading":"1.2.4 Mutate","text":"Add new columns change existing ones. Refer columns names (unquoted). can add one column mutate function, just separate columns comma. make new column, can use column definitions (e.g., profit ).can overwrite column giving new column name old column (see region) . Make sure mean trying use old column value redefine .","code":"\nbudget2 <- budget %>%\n  mutate(\n    sales = sales_2019 + sales_2020,\n    expenses = expenses_2019 + expenses_2020,\n    profit = sales - expenses,\n    region = paste(region, \"Office\")\n  )"},{"path":"wrangle.html","id":"dplyr-summarise","chapter":"1 Data Wrangling","heading":"1.2.5 Summarise","text":"introduced summarise() function Chapter @({#summary-summarise}). applies summary functions entire table (groups, see next section).say want determine mean sales expenses, plus minimum maximum profit, region, product year. First, need reshape data like learned Chapter ??, column year one column sales expenses, instead separate columns year.Now can create summary statistics table.","code":"\nbudget3 <- budget %>%\n  pivot_longer(cols = sales_2019:expenses_2020,\n               names_to = c(\"type\", \"year\"),\n               names_sep = \"_\",\n               values_to = \"value\") %>%\n  pivot_wider(names_from = type,\n              values_from = value)\n\nhead(budget3) # check the format\nbudget3 %>%\n  summarise(\n    mean_sales = mean(sales),\n    mean_expenses = mean(expenses),\n    min_profit = min(expenses - sales),\n    max_profit = max(expenses - sales)\n  )"},{"path":"wrangle.html","id":"dplyr-groupby","chapter":"1 Data Wrangling","heading":"1.2.6 Group By","text":"introduced group_by() function Chapter ??. example, can break summary statistics year product.find maximum sales region?","code":"\nbudget3 %>%\n  group_by(year, product) %>%\n  summarise(\n    mean_sales = mean(sales),\n    mean_expenses = mean(expenses),\n    min_profit = min(expenses - sales),\n    max_profit = max(expenses - sales),\n    .groups = \"drop\"\n  )budget3 %>%\n  group_by(sales) %>%\n  summarise(max_sales = max(region)budget3 %>%\n  group_by(region) %>%\n  summarise(max_sales = max(region)budget3 %>%\n  group_by(sales) %>%\n  summarise(max_sales = max(sales)budget3 %>%\n  group_by(region) %>%\n  summarise(max_sales = max(sales)"},{"path":"wrangle.html","id":"missing-values","chapter":"1 Data Wrangling","heading":"1.3 Missing values","text":"North region returned sales data 2020 yet?Now, try calculate mean sales profits, get missing values summary value used one North 2020 sales values.NA basically means \"know\", sum 100 \"know\" \"know\", 100. However, calculating means, often want just ignore missing values. Set na.rm = TRUE summary function remove missing values calculating.want find many missing non-missing values column, use .na() function get logical vector whether value missing, use sum() count many values TRUE mean() calculate proportion TRUE values.","code":"\n# set sales values to NA for North 2020 rows\nbudget_missing <- budget3 %>%\n  mutate(sales = ifelse(region == \"North\" & year == 2020, NA, sales))\n\n# check\nfilter(budget_missing, region == \"North\")\nbudget_missing %>%\n  group_by(year, product) %>%\n  summarise(\n    mean_sales = mean(sales),\n    mean_expenses = mean(expenses),\n    min_profit = min(expenses - sales),\n    max_profit = max(expenses - sales),\n    .groups = \"drop\"\n  )\nbudget_missing %>%\n  group_by(year, product) %>%\n  summarise(\n    mean_sales = mean(sales, na.rm = TRUE),\n    mean_expenses = mean(expenses, na.rm = TRUE),\n    min_profit = min(expenses - sales, na.rm = TRUE),\n    max_profit = max(expenses - sales, na.rm = TRUE),\n    .groups = \"drop\"\n  )\nbudget_missing %>%\n  group_by(year, product) %>%\n  summarise(\n    n_valid = sum(!is.na(sales)),\n    n_missing = sum(is.na(sales)),\n    prop_missing = mean(is.na(sales)),\n    .groups = \"drop\"\n  )"},{"path":"wrangle.html","id":"together-wrangle","chapter":"1 Data Wrangling","heading":"1.4 Putting it together","text":"Load demo data first used Chapter ??. Use glimpse() another method get familiar data set.Double check SALES column equal QUANTITYORDERED column times PRICEEACH. can select just columns need rename selecting make code readable.Make table rows value total equal SALES.check errors table, see 1697 original 2823 rows \"errors\", even though many values SALES sales_check columns look identical. can fix rounding value total 2 decimal places.due way values decimal places represented computer. use base 10 count, represent numbers repeating decimal, like 1/3 .0333 repeating, computer uses binary count, represent different numbers using repeats. can lead small differences divide multiply numbers.still 1304 errors! Lets look 10 smallest. can calculating difference, arranging smallest largest, filtering first 10 rows.Alternatively, can use slice function.plot data, looks like errors one direction.look data separately products price exactly 100 versus products.looks like problem dataset: PRICEEACH column go 100. fix dividing total sale price quantity ordered.Now can re-run code find errors. adding ORDERNUMBER next step.5 instances quantity ordered divide total price way produces prices round nearest cent. might require investigation, just set value SALES missing orders errors tables.Now fixed () problems dataset, see can figure make table . take 5 steps.","code":"\n# from https://www.kaggle.com/kyanyoga/sample-sales-data\nsales <- read_csv(\"data/sales_data_sample.csv\",\n                  show_col_types = FALSE)\nsales_check <- sales %>%\n  select(SALES, n = QUANTITYORDERED, price = PRICEEACH) %>%\n  mutate(total = n * price)\nerrors <- sales_check %>%\n  filter(SALES != total)\n\nhead(errors)\noptions(scipen = 20) # avoids scientific notation\nx = (1/49 * 49)\nx # prints as 1\n1-x # but is actually very slightly smaller## [1] 1\n## [1] 0.0000000000000001110223\nerrors <- sales_check %>%\n  filter(SALES != round(total, 2))\nerrors %>%\n  mutate(diff = SALES - total) %>%\n  arrange(diff) %>%\n  filter(row_number() <= 10)\nerrors %>%\n  mutate(diff = SALES - total) %>%\n  slice_min(order_by = diff, n = 10)\nggplot(errors, aes(x = SALES, y = total)) + \n  geom_point(alpha = 0.5) +\n  geom_abline(slope = 1, intercept = 0) +\n  coord_cartesian(xlim = c(0, 15000), ylim = c(0, 8000))\nsales_check %>%\n  mutate(price100 = price == 100) %>%\n  ggplot(aes(x = SALES, y = total, color = price100)) + \n  geom_point(alpha = 0.5) +\n  geom_abline(slope = 1, intercept = 0) +\n  coord_cartesian(xlim = c(0, 15000), ylim = c(0, 8000))\nfixed_sales <- sales %>%\n  mutate(PRICEEACH = round(SALES / QUANTITYORDERED, 2))\nsales_check <- fixed_sales %>%\n  select(ORDERNUMBER, \n         SALES, \n         n = QUANTITYORDERED, \n         price = PRICEEACH) %>%\n  mutate(total = n * price)\n\nerrors <- sales_check %>%\n  filter(SALES != round(total, 2))\n\nerrors\nfixed_sales <- fixed_sales %>%\n  mutate(SALES = ifelse(\n    test = ORDERNUMBER %in% errors$ORDERNUMBER,\n    yes = NA,\n    no = SALES)\n  )\nfixed_sales %>%\n  filter(PRODUCTLINE %in% c(\"Planes\", \"Ships\", \"Trains\")) %>%\n  group_by(YEAR_ID, PRODUCTLINE) %>%\n  summarise(total = sum(SALES, na.rm = TRUE),\n            .groups = \"drop\") %>%\n  mutate(total = round(total)) %>%\n  pivot_wider(names_from = YEAR_ID,\n              values_from = total)"},{"path":"wrangle.html","id":"exercises","chapter":"1 Data Wrangling","heading":"1.5 Exercises","text":"","code":""},{"path":"wrangle.html","id":"mutate-1","chapter":"1 Data Wrangling","heading":"1.5.1 Mutate","text":"Load data population Scottish counties.Transform population value nearest thousands (e.g., 3433 \"3K\"), order least populous, put columns order population (K) county, show counties populations greater 200K.several different ways make table . functions different order . See can move filter() arrange() functions.","code":"\nscotpop <- read_csv(\"data/scottish_population.csv\",\n                    show_col_types = FALSE)\nscotpop %>%\n  arrange(desc(population)) %>%\n  filter(population > 200000) %>%\n  mutate(kpop = round(population/1000) %>% paste0(\"K\")) %>%\n  select(population = kpop, \n         county = name)"},{"path":"wrangle.html","id":"glossary-wrangle","chapter":"1 Data Wrangling","heading":"1.6 Glossary","text":"","code":""},{"path":"wrangle.html","id":"resources-wrangle","chapter":"1 Data Wrangling","heading":"1.7 Further resources","text":"Data transformation cheat sheetChapter 5: Data Transformation R Data Science","code":""}]
